<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QTRSensors library: Usage Notes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QTRSensors library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Usage Notes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Calibration </h2>
<p>This library allows you to use the <a class="el" href="class_q_t_r_sensors.html#a0021d844b691e1cf9e0fac2530b89c7e" title="Reads the sensors for calibration.">QTRSensors::calibrate()</a> method to easily calibrate your sensors for the particular conditions it will encounter. Calibrating your sensors can lead to substantially more reliable sensor readings, which in turn can help simplify your code. As such, we recommend you build a calibration phase into your applicationâ€™s initialization routine. This can be as simple as a fixed duration over which you repeatedly call the <code>calibrate()</code> method. During this calibration phase, you will need to expose each of your reflectance sensors to the lightest and darkest readings they will encounter. For example, if you have made a line follower, you will want to slide it across the line during the calibration phase so the each sensor can get a reading of how dark the line is and how light the ground is. A sample calibration routine would be:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_q_t_r_sensors_8h.html">QTRSensors.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="class_q_t_r_sensors.html">QTRSensors</a> qtr;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup()</div><div class="line">{</div><div class="line">  <span class="comment">// Optional: wait for some input from the user, such as a button press.</span></div><div class="line"></div><div class="line">  <span class="comment">// Initialize the sensors.</span></div><div class="line">  <span class="comment">// In this example we have three sensors on pins A0 - A2.</span></div><div class="line">  qtr.<a class="code" href="class_q_t_r_sensors.html#a411f4a800c4e297a6b0ada8efece043d">setTypeRC</a>(); <span class="comment">// or setTypeAnalog()</span></div><div class="line">  qtr.<a class="code" href="class_q_t_r_sensors.html#affa15ba6cbde69fd375f41e5fc63b156">setSensorPins</a>((<span class="keyword">const</span> uint8_t[]){A0, A1, A2}, 3);</div><div class="line"></div><div class="line">  <span class="comment">// Optional: change parameters like RC timeout, set an emitter control pin...</span></div><div class="line"></div><div class="line">  <span class="comment">// Then start the calibration phase and move the sensors over both reflectance</span></div><div class="line">  <span class="comment">// extremes they will encounter in your application. This calibration should</span></div><div class="line">  <span class="comment">// take about 5 seconds (250 iterations * 20 ms per iteration).</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Passing a QTRReadMode to calibrate() is optional; it should match the mode</span></div><div class="line">  <span class="comment">// you plan to use when reading the sensors.</span></div><div class="line">  <span class="keywordflow">for</span> (uint8_t i = 0; i &lt; 250; i++)</div><div class="line">  {</div><div class="line">    qtr.<a class="code" href="class_q_t_r_sensors.html#a0021d844b691e1cf9e0fac2530b89c7e">calibrate</a>();</div><div class="line">    delay(20);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Optional: signal that the calibration phase is now over and wait for</span></div><div class="line">  <span class="comment">// further input from the user, such as a button press.</span></div><div class="line">}</div></div><!-- fragment --><h2>Reading the sensors </h2>
<p>This library gives you a number of different ways to read the sensors. All of these take an optional <code>mode</code> argument that determines how the IR emitters behave during the reading. (The options available depend on what sensor board you have; see <a class="el" href="_q_t_r_sensors_8h.html#a3de40c1ece9200d5dcd314dcfe655a6e" title="Emitter behavior when taking readings.">QTRReadMode</a> for details.)</p>
<ol type="1">
<li>You can request raw sensor values using the <a class="el" href="class_q_t_r_sensors.html#a92f25ec98543d6e87bf65a9db67c69ef" title="Reads the raw sensor values into an array.">QTRSensors::read()</a> method.</li>
<li>You can request calibrated sensor values using the <a class="el" href="class_q_t_r_sensors.html#aa2f5d7779744e5d93f6935d2cdf589eb" title="Reads the sensors and provides calibrated values between 0 and 1000.">QTRSensors::readCalibrated()</a> method. Calibrated sensor values will always range from 0 to 1000, with 0 corresponding to the most reflective (brightest) surface encountered during calibration, and 1000 corresponding to the least reflective (darkest).</li>
<li>For line-detection applications, you can request the line location using the <a class="el" href="class_q_t_r_sensors.html#a8f2a5239ae547928284c5f81cd7ec89c" title="Reads the sensors, provides calibrated values, and returns an estimated black line position.">QTRSensors::readLineBlack()</a> or <a class="el" href="class_q_t_r_sensors.html#a231f1ef20c2a7ba325bdb794fc2dedf9" title="Reads the sensors, provides calibrated values, and returns an estimated white line position.">QTRSensors::readLineWhite()</a> methods. These are intended for use with a black line on a white background or a white line on a black background, respectively. Each of these methods provides calibrated readings for each sensor and returns an integer that tells you where it thinks the line is. If you are using N sensors, a returned value of 0 means it thinks the line is on or to the outside of sensor 0, and a returned value of 1000 &times; (N&minus;1) means it thinks the line is on or to the outside of sensor N&minus;1. As you slide your sensors across the line, the line position will change monotonically from 0 to 1000 &times; (N&minus;1), or vice versa. This line-position value can be used for closed-loop PID control.</li>
</ol>
<p>A sample routine to obtain the sensor values and perform rudimentary line following would be:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> loop()</div><div class="line">{</div><div class="line">  uint16_t sensors[3];</div><div class="line">  <span class="comment">// Get calibrated sensor values returned in the sensors array, along with the</span></div><div class="line">  <span class="comment">// line position, which will range from 0 to 2000, with 1000 corresponding to</span></div><div class="line">  <span class="comment">// a position under the middle sensor.</span></div><div class="line">  int16_t position = qtr.<a class="code" href="class_q_t_r_sensors.html#a8f2a5239ae547928284c5f81cd7ec89c">readLineBlack</a>(sensors);</div><div class="line"></div><div class="line">  <span class="comment">// If all three sensors see very low reflectance, take some appropriate action</span></div><div class="line">  <span class="comment">// for this  situation.</span></div><div class="line">  <span class="keywordflow">if</span> ((sensors[0] &gt; 750) &amp;&amp; (sensors[1] &gt; 750) &amp;&amp; (sensors[2] &gt; 750))</div><div class="line">  {</div><div class="line">    <span class="comment">// Do something. Maybe this means we&#39;re at the edge of a course or about to</span></div><div class="line">    <span class="comment">// fall off a table, in which case we might want to stop moving, back up,</span></div><div class="line">    <span class="comment">// and turn around.</span></div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Compute our &quot;error&quot; from the line position. We will make it so that the</span></div><div class="line">  <span class="comment">// error is zero when the middle sensor is over the line, because this is our</span></div><div class="line">  <span class="comment">// goal. Error will range from -1000 to +1000. If we have sensor 0 on the left</span></div><div class="line">  <span class="comment">// and sensor 2 on the right,  a reading of -1000 means that we see the line</span></div><div class="line">  <span class="comment">// on the left and a reading of +1000 means we see the line on the right.</span></div><div class="line">  int16_t error = position - 1000;</div><div class="line"></div><div class="line">  int16_t leftMotorSpeed = 100;</div><div class="line">  int16_t rightMotorSpeed = 100;</div><div class="line">  <span class="keywordflow">if</span> (error &lt; -500)</div><div class="line">  {</div><div class="line">    <span class="comment">// the line is on the left</span></div><div class="line">    leftMotorSpeed = 0;  <span class="comment">// turn left</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">if</span> (error &gt; 500)</div><div class="line">  {</div><div class="line">    <span class="comment">// the line is on the right</span></div><div class="line">    rightMotorSpeed = 0;  <span class="comment">// turn right</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// set motor speeds using the two motor speed variables above</span></div><div class="line">}</div></div><!-- fragment --><h2>PID Control </h2>
<p>The integer value returned by <a class="el" href="class_q_t_r_sensors.html#a231f1ef20c2a7ba325bdb794fc2dedf9" title="Reads the sensors, provides calibrated values, and returns an estimated white line position.">QTRSensors::readLineWhite()</a> or <a class="el" href="class_q_t_r_sensors.html#a8f2a5239ae547928284c5f81cd7ec89c" title="Reads the sensors, provides calibrated values, and returns an estimated black line position.">QTRSensors::readLineBlack()</a> can be easily converted into a measure of your position error for line-following applications, as was demonstrated in the previous code sample. The function used to generate this position/error value is designed to be monotonic, which means the value will almost always change in the same direction as you sweep your sensors across the line. This makes it a great quantity to use for PID (proportional&ndash;integral&ndash;derivative) control.</p>
<p>Explaining PID control is beyond the scope of this document, but Wikipedia has a good <a href="https://en.wikipedia.org/wiki/PID_controller">article</a> on the subject.</p>
<p>The following code gives a very simple example of PD (proportional&ndash;derivative) control (we find the integral term is usually not necessary for line following). The specific constants will be determined by your particular application, but note that the derivative constant Kd is usually much bigger than the proportional constant Kp. This is because the derivative (rate of change) of the error is a much smaller quantity than the error itself, so in order to produce a meaningful correction, it needs to be multiplied by a much larger constant.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> loop()</div><div class="line">{</div><div class="line">  <span class="keyword">static</span> uint16_t lastError = 0;</div><div class="line"></div><div class="line">  uint16_t sensors[3];</div><div class="line">  <span class="comment">// Get calibrated sensor values returned in the sensors array, along with the</span></div><div class="line">  <span class="comment">// line position, which will range from 0 to 2000, with 1000 corresponding to</span></div><div class="line">  <span class="comment">// a position under the middle sensor</span></div><div class="line">  int16_t position = qtr.<a class="code" href="class_q_t_r_sensors.html#a8f2a5239ae547928284c5f81cd7ec89c">readLineBlack</a>(sensors);</div><div class="line"></div><div class="line">  <span class="comment">// Compute our &quot;error&quot; from the line position. We will make it so that the</span></div><div class="line">  <span class="comment">// error is zero when the middle sensor is over the line, because this is our</span></div><div class="line">  <span class="comment">// goal. Error will range from -1000 to +1000. If we have sensor 0 on the left</span></div><div class="line">  <span class="comment">// and sensor 2 on the right, a reading of -1000 means that we see the line on</span></div><div class="line">  <span class="comment">// the left and a reading of +1000 means we see the line on the right.</span></div><div class="line">  int16_t error = position - 1000;</div><div class="line"></div><div class="line">  <span class="comment">// Set the motor speed based on proportional and derivative PID terms:</span></div><div class="line">  <span class="comment">// KP is the floating-point proportional constant (maybe start with a value around 0.1)</span></div><div class="line">  <span class="comment">// KD is the floating-point derivative constant (maybe start with a value around 5)</span></div><div class="line">  <span class="comment">// Note that when doing PID, it is very important you get your signs right, or</span></div><div class="line">  <span class="comment">// else the control loop will be unstable.</span></div><div class="line">  int16_t motorSpeed = KP * error + KD * (error - lastError);</div><div class="line">  lastError = error;</div><div class="line"></div><div class="line">  <span class="comment">// M1 and M2 are base motor speeds (the speeds the motors should run if you</span></div><div class="line">  <span class="comment">// are perfectly on the line with no error). If your motors are well matched,</span></div><div class="line">  <span class="comment">// M1 and M2 will be equal. When you start testing your PID loop, it might</span></div><div class="line">  <span class="comment">// help to start with small values for M1 and M2. You can then increase the</span></div><div class="line">  <span class="comment">// speed as you fine-tune your PID constants KP and KD.</span></div><div class="line">  int16_t m1Speed = M1 + motorSpeed;</div><div class="line">  int16_t m2Speed = M2 - motorSpeed;</div><div class="line"></div><div class="line">  <span class="comment">// It might help to keep the speeds positive (this is optional). You might</span></div><div class="line">  <span class="comment">// also want to add a similar check to keep the speeds from exceeding a</span></div><div class="line">  <span class="comment">// maximum limit.</span></div><div class="line">  <span class="keywordflow">if</span> (m1Speed &lt; 0) { m1Speed = 0; }</div><div class="line">  <span class="keywordflow">if</span> (m2Speed &lt; 0) { m2Speed = 0; }</div><div class="line"></div><div class="line">  <span class="comment">// set motor speeds using the two motor speed variables above</span></div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
