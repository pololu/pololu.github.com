<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
<title>
  File: PreventingCallStackOverflow
  
    &mdash; Documentation by YARD 0.8.7.4
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '';
  framesUrl = "frames.html#!file.PreventingCallStackOverflow.html";
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    
        <a href="_index.html">Index</a> &raquo;
        
        <a href="file.Manual.html">RPicSim manual</a> &raquo;
    
    <span class="title">File: PreventingCallStackOverflow</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><div id='filecontents'>
<h1 id="label-Preventing+call+stack+overflow">Preventing call stack overflow</h1>

<p>PIC microcontrollers feature a stack implemented in hardware that keeps
track of return addresses for subroutine calls. Every time a
<code>CALL</code> instruction is executed, the return address is pushed
onto the stack. Every time a <code>RETURN</code> or similar instruction is
executed, the return address is popped off of the stack.</p>

<p>The call stack has a limited depth that depends on the device you are
using. If your program has too many levels of nested subroutines then the
call stack could overflow. Depending on the device, a call stack overflow
could cause a reset or incorrect program execution. Therefore, it is
important to avoid a call stack overflow.</p>

<p>RPicSim can trace all the possible paths of execution for a PIC program in
order to calculate what the maximum possible call stack depth is. You can
easily add this to your RSpec tests. Here is an example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_describe'>describe</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>call stack</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_subject'>subject</span><span class='lparen'>(</span><span class='symbol'>:call_stack_info</span><span class='rparen'>)</span> <span class='kw'>do</span>
    <span class='const'>RPicSim</span><span class='op'>::</span><span class='const'>CallStackInfo</span><span class='period'>.</span><span class='id identifier rubyid_hash_from_program_file'>hash_from_program_file</span><span class='lparen'>(</span><span class='const'>MySim</span><span class='period'>.</span><span class='id identifier rubyid_program_file'>program_file</span><span class='comma'>,</span> <span class='lbracket'>[</span><span class='int'>0</span><span class='comma'>,</span> <span class='int'>4</span><span class='rbracket'>]</span><span class='rparen'>)</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_specify'>specify</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>mainline code uses no more than 5 levels</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span>
    <span class='id identifier rubyid_call_stack_info'>call_stack_info</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_max_depth'>max_depth</span> <span class='id identifier rubyid_be'>be</span> <span class='op'>&lt;=</span> <span class='int'>5</span>
  <span class='kw'>end</span>

  <span class='id identifier rubyid_specify'>specify</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ISR code uses no more than 1 level</span><span class='tstring_end'>&quot;</span></span> <span class='kw'>do</span>
    <span class='id identifier rubyid_call_stack_info'>call_stack_info</span><span class='lbracket'>[</span><span class='int'>4</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_max_depth'>max_depth</span><span class='period'>.</span><span class='id identifier rubyid_should'>should</span> <span class='id identifier rubyid_be'>be</span> <span class='op'>&lt;=</span> <span class='int'>1</span>
  <span class='kw'>end</span>
<span class='kw'>end</span></code></pre>

<p>This example is for a PIC10F322 program. The mainline code's entry point is
at address 0, and the first RSpec example makes sure that the maximum depth
of subroutine calls in the mainline code is 5. The firmware uses an
interrupt and the interrupt vector is at address 4. The second RSpec
example makes sure that the ISR uses at most one level of the call stack
(the ISR itself can only call one subroutine).</p>

<p>If the two tests above pass, then we can calculate the maximum amount of
call stack space that might ever be used. If the mainline code is at its
deepest point and it is interrupted by an ISR that happens to reach its
deepest point, then the call stack would have:</p>
<ul><li>
<p>5 levels used by the mainline code.</p>
</li><li>
<p>1 level used by the processor itself to store the address to return to when
the interrupt is done.</p>
</li><li>
<p>1 level used by the ISR code.</p>
</li></ul>

<p>The means there can be at most 7 things stored on the call stack, which is
safely below the PIC10F322's limit of 8.</p>

<p>Suppose RPicSim tells you that your mainline code could take 5 levels of
the stack and you are not sure why. The
<span class='object_link'><a href="RPicSim/CallStackInfo.html#worst_case_code_paths_filtered_report-instance_method" title="RPicSim::CallStackInfo#worst_case_code_paths_filtered_report (method)">RPicSim::CallStackInfo#worst_case_code_paths_filtered_report</a></span> can produce
a set of example code paths that demonstrate how the maximum depth could
potentially happen. To see the report, just add a line like this:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_call_stack_info'>call_stack_info</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_worst_case_code_paths_filtered_report'>worst_case_code_paths_filtered_report</span></code></pre>

<p>The report will be a series of code paths that look something like this:</p>

<pre class="code plain"><code class="plain">CodePath:
Instruction(0x0000, GOTO 0x20)
Instruction(0x0024 = start2, CALL 0x40)
Instruction(0x0040 = foo, CALL 0x41)
Instruction(0x0041 = goo, CALL 0x60)
Instruction(0x0060 = hoo, CALL 0x80)
Instruction(0x0080 = ioo, CALL 0x100)
Instruction(0x0100 = joo, CLRF 0x7)</code></pre>

<p>This example code path shows five CALL instructions that could potentially
be nested.</p>

<h2 id="label-How+it+works">How it works</h2>

<p>The <span class='object_link'><a href="RPicSim/ProgramFile.html" title="RPicSim::ProgramFile (class)">RPicSim::ProgramFile</a></span> class uses the MPLAB X disassembler to provide a
graph with every reachable instruction in the firmware. The
<span class='object_link'><a href="RPicSim/CallStackInfo.html" title="RPicSim::CallStackInfo (class)">RPicSim::CallStackInfo</a></span> class traverses all possible paths through that
graph from a given entry point to calculate the maximum possible call stack
depth at every point in the graph.</p>

<h2 id="label-Limitations">Limitations</h2>

<p>The algorithm is pessimistic:</p>
<ul><li>
<p>It does not try to track the runtime values of any of your program's
variables in order to predict which code paths will happen.</p>
</li><li>
<p>It cannot handle recursive functions because there is no way for it to
figure out the maximum level of recursion.</p>
</li><li>
<p>It does not know when interrupts are enabled.</p>
</li></ul>

<p>All of those things are OK because they can only cause the algorithm to
give an answer that is more pessimistic than reality; the reported maximum
call stack depth might be higher than what is actually possible.</p>

<p>However, there are some things that can mess up the algorithm in a bad way
and give you incorrect results:</p>
<ul><li>
<p>If you write to the PC register in order to do a computed jump, the
algorithm does not currently detect that and will not correctly consider
code paths coming from that instruction.  Be careful about this, because a
computed jump might be generated automatically by a C compiler.</p>
</li><li>
<p>Similarly, it cannot handle jumps on devices that have paged memory. In
order to determine where a jump actually goes, it would need to know what
page is selected by looking at the history of the program's execution.</p>
</li><li>
<p>It does not account for the effect of PUSH and POP instructions on the call
stack depth.</p>
</li></ul>

<p>This code is not suitable (yet) for any firmware that uses a computed jump,
paged program memory, or PUSH or POP instructions.</p>

<p>This code only checks the hardware call stack; it does not check any kind
of data stack that your compiler might use to store the values of local
variables.</p>
</div></div>

    <div id="footer">
  
    This is part of the <a href="file.Manual.html">RPicSim manual</a>.
  
  <br/><br/>

  Generated on Mon Mar 17 12:27:05 2014 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.4 (ruby-1.9.3).
</div>

  </body>
</html>